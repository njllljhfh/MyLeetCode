# -*- coding:utf-8 -*-
"""
与以上示例类似(020_作用域和闭包_作用域同名互斥性.py)，
在内嵌函数中，也具有同样的特性，以下代码是在 Python 中使用闭包时一段经典的错误代码。
"""


def foo():
    a = 0

    def bar():
        a = a + 1  # 或 a += 1
        return a

    return bar


c = foo()
print(c())

"""
以上代码并未如预期打印出来数字 1。
根据闭包函数的机制进行分析，c 变量对应的闭包包含两部分，
变量环境 a = 0 和函数体 a = a + 1。 
问题出在，函数体中的变量 a 和变量环境中的 a 不是同一个。
"""

"""
Python 语言规则指定，所有在赋值语句左边的变量名如果是第一次出现在当前作用域中，都将被定义为当前作用域的变量。
由于在闭包 bar() 中，变量 a 在赋值符号 “=” 的左边，被 Python 认为是 bar() 中的局部变量。
再接下来执行 c() 时，程序运行至 a = a + 1 时，因为先前已经把 a 定义为 bar() 中的局部变量，
由于作用域同名互斥性，右边 a + 1 中的 a 只能是局部变量 a，但是它并没有定义，所以会报错。


注意：
    a 是一个 int型，在 python 中是 不可变类型
    这里是对 a 进行重新赋值（相当于写数据的操作），如果只读取a的值，不修改a的值时，是可以正常访问a的。
"""
